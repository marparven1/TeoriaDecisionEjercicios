---
title: "Teoría de la decisión"
subtitle: "Relación 2"
author: "Marta Venegas Pardo"
output: 
  prettydoc::html_pretty:
    theme: leonids
    highlight: github
    toc: true
    toc_depth: 4
    number_section: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```



```{r  message=FALSE }
source("teoriadecision_funciones_multicriterio.R")
source("teoriadecision_funciones_multicriterio_diagram.R")
source("teoriadecision_funciones_multicriterio_utiles.R")
```



# Ejercicio 1
Dadas las siguientes matrices correspondientes a la relación binaria no borrosa de preferencia-indiferencia:

Construya una función de valor o utilidad asociada a cada una de ellas.

Nota: A este ejercicio podemos resolverlo por el método borroso, pero el ejericio dos no podemos por el criterio maximal


## Apartado a)

### Método maximal

```{r}
m01A = multicriterio.crea.matrizvaloraciones(
  c(1,0,1,1,1,1,0,0,1), numalternativas = 3,
  v.nombres.alternativas = NULL
)
m01A
```

Método de construcción de la función de utilidad "Maximal".



```{r}
sol01A = multicriterio.constfuncutilidad.maximales(m01A)
sol01A
```

Ordenadas de mejor a peor:

```{r}
sort(sol01A,decreasing = TRUE)
```


### Método borroso

Método de construcción de la función de utilidad "Borroso"

```{r}
sol01A.bor = multicriterio.constfuncutilidad.estructuraborrosa(m01A)
sol01A.bor
```

Ordenadas de mejor a peor:

```{r}
sort(sol01A.bor,decreasing = TRUE)
```

Tambien dice que la menor es a2, luego a1 y la última a3.


## Apartado b)

```{r}
m01B = multicriterio.crea.matrizvaloraciones(
  c(1,0,1,1,1,1,1,0,1), numalternativas = 3,
  v.nombres.alternativas = NULL
)
m01B
```

```{r}
sol01B = multicriterio.constfuncutilidad.maximales(m01B)
sol01B
```

Ordenadas de mejor a peor:

```{r}
sort(sol01B,decreasing = TRUE)
```






## Apartado c) Falta MB



### Método maximal





```{r}
m01C = multicriterio.crea.matrizvaloraciones(
  c(1,1,1,1,1,1,1,1,1), numalternativas = 3,
  v.nombres.alternativas = NULL
)
m01C
```

```{r}
sol01C = multicriterio.constfuncutilidad.maximales(m01C)
sol01C
```

Ordenadas de mejor a peor:

```{r}
sort(sol01C,decreasing = TRUE)
```




### Método borroso


## Apartado d)

```{r}
m01D = multicriterio.crea.matrizvaloraciones(
  c(1,1,1,0,1,
    0,1,0,0,1,
    1,0,1,0,1,
    1,1,1,1,0,
    0,0,0,0,1), numalternativas = 5,
  v.nombres.alternativas = NULL
)
m01D
```
### Método maximal


Método de construcción de la función de utilidad "Maximal".


```{r}
sol01D = multicriterio.constfuncutilidad.maximales(m01D)
sol01D
```

Ordenadas de mejor a peor:

```{r}
sort(sol01D,decreasing = TRUE)
```

Las alternativas a1 y a3 son iguales, indiferentes.

\(a_4 > a_1 = a_3 > a_2 > a_5\)


### Método borroso 

Método de construcción de la función de utilidad "Borroso"

```{r}
sol01D.bor = multicriterio.constfuncutilidad.estructuraborrosa(m01D)
sol01D.bor
```

Ordenadas de mejor a peor:

```{r}
sort(sol01D.bor,decreasing = TRUE)
```
En el método maximal había empate entre a1 y a3, sin embargo, este método coloca primero a a1. 



\(a_4 > a_1 > a_3 > a_2 > a_5\)








# Ejercicio 2
Dadas las siguientes matrices correspondientes a la relación binaria borrosa de preferencia:

Construya una función de valor o utilidad asociada a cada una de ellas.

## Apartado a)

```{r}
m02A = multicriterio.crea.matrizvaloraciones(
  c(0,0.4,0.7,
    0.2,0,0.5,
    0.3,0.6,0), 
  numalternativas = 3,
  v.nombres.alternativas = NULL
)
m02A
```

No se puede aplicar el método maximal

### Método borroso

Método de construcción de la función de utilidad "Borroso"

```{r}
sol02A.bor = multicriterio.constfuncutilidad.estructuraborrosa(m02A)
sol02A.bor
```



Ordenadas de mejor a peor:

```{r}
sort(sol02A.bor,decreasing = TRUE)
```

En este caso a1 sería la mejor, y existe un empate entre a2 y a3.



## Apartado B

```{r}
m02B = multicriterio.crea.matrizvaloraciones(
  c(0,0.2,0.4,
    0.9,0,0.8,
    0.1,0.3,0), 
  numalternativas = 3,
  v.nombres.alternativas = NULL
)
m02B
```

### Método borroso

Método de construcción de la función de utilidad "Borroso"

```{r}
sol02B.bor = multicriterio.constfuncutilidad.estructuraborrosa(m02B)
sol02B.bor
```



Ordenadas de mejor a peor:

```{r}
sort(sol02B.bor,decreasing = TRUE)
```







# Ejercicio 3
Dada una matriz de decisióon recogida en la siguiente tabla:


## Apartado a)




```{r}
m03= multicriterio.crea.matrizdecision( 
  c(100,15,7,40,50,
    200,25,7,60,200,
    100,20,4,25,25,
    200,30,20,70,350,
    250,25,15,100,500), 
  numalternativas = 5,
  numcriterios = 5,
)
m03
```

### Con criterio maximinzar



Homogeneice las columnas de la tabla de decisión por el método Nadir


```{r}
sol03A=multicriterio.homogeneizacion.nadir(m03)
sol03A
```

- Matriz en escala (0,1). 

- 100 es el mínimo, por eso lleva valor 0 y 250 es el mayor, lleva un 1. Luego el resto es una regla de 3.

- Así para cada criterio.




Nota: Si me dicen previamente que es minimizar, le cambio el signo a todo y me daría los 1 donde están los valores más pequeños:

### Apartado a con Criterio de minimizar

```{r}
m0302= multicriterio.crea.matrizdecision( 
  c(- 100,15,7,40,50,
    - 200,25,7,60,200,
    - 100,20,4,25,25,
    - 200,30,20,70,350,
    - 250,25,15,100,500), 
  numalternativas = 5,
  numcriterios = 5,
)
m0302
```



```{r}
sol03A02=multicriterio.homogeneizacion.nadir(m0302)
sol03A02
```




## Apartado b)

Homogeneice las columnas de la tabla de decisión por el método Promethee, considerando los siguientes valores $\underline\delta$ y $\overline\delta$ para cada uno de los criterios: C1 : (30, 120), C2 : (3, 12), C3 : (4, 10), C4 : (20, 60) y C5 : (100, 400), respectivamente.

```{r}
sol03B =multicriterio.homogeneizacion.promethee(m03,
                                        v.delta.min = c(30,3,4,20,100),
                                        v.delta.max = c(120,12,10,60,400))
sol03B
```


# Ejercicio 4
Un inversor está considerando invertir en una opción entre dos alternativas posibles A y B. El criterio de mayor importancia relativa es el rendimiento de cada opción en Bolsa, y en menor medida el riesgo asociado con dicha inversión. Las matrices de comparación por pares de este problema han sido estimadas de la manera siguiente:

- Matriz de criterios 

- Matriz de alternativas/criterios



Se pide:

Apartado a)
Identificar el diagrama de jerarquías de este problema de decisión.

Apartado b)

Calcular las prioridades de cada matriz de comparaciones por pares. 

Apartado c)

Determinar la prioridad global de cada una de las 2 inversiones.



Lo resuelvo siguiendo los pasos del fichero esquemaAHPcalculos


# Nuevo paquete


```{r}
#devtools::install_github("gluc/ahp", build_vignettes = TRUE)
```
```{r}
#vignette("car-example", package = "ahp")
#vignette("multiple-decisionmakers", package = "ahp")
#
## run analysis
#library(ahp)
#ahpFile <- system.file("extdata", "car.ahp", package="ahp")
#carAhp <- Load(ahpFile)
#Calculate(carAhp)
#Visualize(carAhp)
#Analyze(carAhp)
#AnalyzeTable(carAhp)
#
## looking at the vacation example, a multi-decision-maker model
#ahpFile <- system.file("extdata", "vacation.ahp", package="ahp")
#vacationAhp <- Load(ahpFile)
#Calculate(vacationAhp)
#Analyze(vacationAhp, decisionMaker = "Dad")
#AnalyzeTable(vacationAhp, decisionMaker = "Mom")
#AnalyzeTable(vacationAhp)
```

```{r}
#RunGUI()
```






## Funciones en script de R

Introducir los datos 

```{r}
nb.criterios=c("Rendimiento","Riesgo")
tb0401 = multicriterio.crea.matrizvaloraciones_mej(c(2),
                                                  numalternativas = 2,
                                                  v.nombres.alternativas = nb.criterios) # la diagonal superior

tb0401
```


```{r}
# la del rendimiento
nb.alternativas=c("A","B")
tb0402a = multicriterio.crea.matrizvaloraciones_mej(c(3),
                                                  numalternativas = 2,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0402a
```

```{r}
# la del riesgo
nb.alternativas=c("A","B")
tb0402b = multicriterio.crea.matrizvaloraciones_mej(c(1/2),
                                                  numalternativas = 2,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0402b
```

Obtenemos los pesos locales:

```{r}
(pl0401 = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0401)) #pesoslocales0401
```


```{r}
(pl0402a = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0402a)) #pesoslocales0402a

```


```{r}
(pl0402b = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0402b)) #pesoslocales0402b
```

Nos queda obtener finalmente los pesos globales:

```{r}
(sol04=multicriterio.metodoAHP.pesosglobales_entabla(pl0401$valoraciones.ahp,
                                              rbind(pl0402a$valoraciones.ahp,
                                                    pl0402b$valoraciones.ahp)))
```

El 61% y el 39%. Esta claro que la alternativa elegida es la A, es casi el doble mejor. En cuanto al rendimiento es mejor la A 3 veces mejor que la B pero respecto al riesgo es mejor la B que la A. El rendimiento tiene el doble de importancia que el riesgo, por eso gana la A.

El diagrama con la estructura jerárquica:

```{r}
xmatn01=tb0401 # meto la tabla tb0401
xmatn02=array(NA,dim=c(2,2,2))
xmatn02[,,1]=tb0402a
xmatn02[,,2]=tb0402b
dimnames(xmatn02)[[1]]=nb.alternativas
dimnames(xmatn02)[[2]]=nb.alternativas
dimnames(xmatn02)[[3]]=nb.criterios
multicriterio.metodoahp.diagrama(xmatn01,xmatn02) # matriz del nivel 1 y 2
```
Ejercicios 5y6 son iguales pero con sus datos.


## Con paquete ahp



```{r}
#devtools::install_github("gluc/ahp", build_vignettes = TRUE)
# ahp::RunGUI()
# 
library(ahp)
dt04 = Load("ej04.ahp")
```


```{r message=FALSE}
#suppressPackageStartupMessages(Visualize(dt04))
#suppressMessages(Visualize(dt04))
Visualize(dt04)
```



```{r}
ahp::Calculate(dt04)
ahp::AnalyzeTable(dt04, sort="orig",variable="priority")
```

```{r}
ahp::AnalyzeTable(dt04, sort="orig")
```
El rendimiento es casi el doble de importante que el riesgo.

Hacer más comentarios

# Ejercicio 5

El vicepresidente ejecutivo de una empresa de distribución de bebidas necesita seleccionar un nuevo gerente de marketing.

Hay dos candidatos potenciales cuyas iniciales son A y B. Se han identificado las siguientes matrices de comparación por pares:

- Matriz de comparación entre criterios

- Matriz de comparación entre alternativas según criterios

Se pide:

## Apartado a)
Identificar el diagrama de jerarquías de este problema de decisión.

## Apartado b)
Calcular las prioridades de cada matriz de comparaciones por pares.

## Apartado c) 
Determinar la prioridad global de cada candidato.


# Ejercicio 6

Una empresa de diseño debe seleccionar la mejor oferta entre 3 alternativas de proveedores:

A, B y C. 

La Gerencia de la empresa maneja tres criterios (1) los costos, (2) la confiabilidad de los productos y (3) plazos de entrega.

El centro decisor fue consultado sobre sus preferencias en relación con cada uno de los provee- dores. Se identificaron las siguientes matrices de comparación por parejas entre los proveedores según uno de los 3 criterios:



# Ejercicio 7

```{r}
p7 = multicriterio.crea.matrizdecision(
  vector_matporfilas = c(
  100 ,15 ,7 ,40   ,-50,
  200 ,25 ,7 ,60   ,-200,
  100 ,20 ,4 ,25   ,-25,
  200 ,30 ,20, 70  ,-350,
  250 ,25 ,15, 100 ,-500),
  numalternativas = 5,
  numcriterios = 5
  
 
)
(w=c(0.25,0.25,0.2,0.2,0.2))
(vd = c(60,Inf,4,Inf,Inf))
```

```{r}
sal7i1=multicriterio.metodoELECTRE_I(p7,pesos.criterios = w,
                                   nivel.concordancia.minimo.alpha = 0.7,
                                   no.se.compensan = vd,
                                   que.alternativas = TRUE
                                   )
#sal7i1
```

Representación del grafo

```{r}
qgraph::qgraph(sal7i1$relacion.dominante)
```
En la siguiente iteración:

```{r}
sal7i2=multicriterio.metodoELECTRE_I(p7,pesos.criterios = w,
                                   nivel.concordancia.minimo.alpha = 0.7,
                                   no.se.compensan = vd,
                                   que.alternativas = c(4,5)
                                   )
sal7i2$relacion.dominante
sal7i2$nucleo_aprox
```


```{r}
qgraph::qgraph(sal7i2$relacion.dominante)
```

En la siguiente iteración:

```{r}
sal7i3=multicriterio.metodoELECTRE_I(p7,pesos.criterios = w,
                                   nivel.concordancia.minimo.alpha = 0.55, #0.65, 0.6
                                    no.se.compensan = vd,
                                   que.alternativas = c(4,5)
                                   )
sal7i3$relacion.dominante
sal7i3$nucleo_aprox # con 0.55 ya se queda solo a4
```

```{r}
qgraph::qgraph(sal7i3$relacion.dominante)
```

Si con 0.5 no somos capaces de establecer una superioridad, decimos que ambas son iguales y ninguna supera a la otra.

Conclusión, mejor alternativa: a4

## La representación de las tables de test con KableExtra

```{r}
library(dplyr)
library(kableExtra)
library(stringr)
sal7ke = func_ELECTRE_Completo(sal7i1)
```

```{r}
sal7ke$MIndices
sal7ke$TConcordancia
```

```{r}
qgraph::qgraph(sal7ke$Grafo)
```

El núcleo

```{r}
sal7ke$Nucleo
```


# Ejercicio 8

## Promethee I

```{r}
tabdec.X = multicriterio.crea.matrizdecision(c(-80,90.-6.-5.4,-8.5,
                                               -65,58 ,-2,-9.7,-1.1,
                                               -83,60,-4,-7.2,-4,7,
                                               -40.80-10,-7.5, -7,10
                                               -52,72,-6,-2.0, -3,8,
                                               -94,96,-7,-3.6,-5,6),
                                             numalternativas=6,
                                             numcriterios=6,
                                             v.nombresalt=c("A1","A2","A3","A4","A5","A6"),
                                             v.nombrescri = c("f1","f2","f3","f4","f5","f6")
                                                    
)
tabdec.X
```


```{r}
sal8= multicriterio.metodo.promethee_i(tabdec.X,
                                      pesos.criterios = rep(1/6,6),
                 tab.fpref=matrix(c(2,10,0,0, # nro ,qi,pi,si
                                    3,0,30,0,
                                    5,0.5,5,0,
                                    4,1,6,0,
                                    1,0,0,0,
                                    6,0,0,5),ncol=4,byrow=TRUE))
```


Representar en un grafo:

```{r}
qgraph::qgraph(sal8$tablarelacionsupera)
```


A5 domina a todos, esa es la mejor


## Promethee II



```{r}
sal8b= multicriterio.metodo.promethee_ii(tabdec.X,
                                      pesos.criterios = rep(1/6,6),
                 tab.fpref=matrix(c(2,10,0,0, # nro ,qi,pi,si
                                    3,0,30,0,
                                    5,0.5,5,0,
                                    4,1,6,0,
                                    1,0,0,0,
                                    6,0,0,5),ncol=4,byrow=TRUE))
```


Representar en un grafo:

```{r}
qgraph::qgraph(sal8b$tablarelacionsupera)
```

```{r}
order(sal8b$vflujos.netos,decreasing = T)
```
Me dice que la 5 es la mejor seguida de la 2, la 4 la 6 la 3 y la 1.



```{r}
pesos.criterios = c(1/6,1/6,1/6,1/6,1/6.1/6) ;
#                   num. función, qi, pi, si
tab.fpref = matrix(c (2,10,1,0,
                      3,0,30,0,
                      5,0.5,5,0, 
                      4,1,6,0,
                      1,0,1,0,
                      6,0,1,5) ,ncol=4, byrow=T);
tab.fpref
```
```{r}
fpref.criterio_usual_di = function(di) {
              #di = vaj-vah;
    if (di <= 0) {
      res= 0;
      } else {
        res= 1;
      }
       return(res) ;
  }
```


Representación Gráfica de las funciones de preferencias


```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,fpref.criterio_usual_di)
plot (x,y, type="l", col="blue" ,main= "Criterio Usua: F1 ")
```

```{r}
fpref.cuasi_criterio_di = function(di,qi) {
              #di = vaj-vah;
    if (di <= qi) {
      res= 0;
      } else {
        res= 1;
      }
       return(res) ;
  }
```





```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,function(xx) fpref.cuasi_criterio_di(xx,qi=2))
plot (x,y, type="l", col="blue" ,main= "Cuasi Criterio. Lineal: F2 (con qi=2)")
```


```{r}
fpref.criterio_preflineal_di = function(di,pi) {
              #di = vaj-vah;
    if (di <= 0) {
      res= 0;
      } else if (di>pi) {
        res= 1;
      } else {
        res=di/pi;
      }
       return(res) ;
  }
```





```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,function(xx) fpref.criterio_preflineal_di(xx,pi=2))
plot (x,y, type="l", col="blue" ,main= "Criterio
      Pref. Lineal: F3 (con pi=2)")
```




```{r}
fpref.criterio_nivel_di = function(di,qi,pi) {
              #di = vaj-vah;
    if (di <= qi) {
      res= 0;
      } else if (di>pi) {
        res= 1;
      } else {
        res=0.5;
      }
       return(res) ;
  }
```





```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,function(xx) fpref.criterio_nivel_di(xx,pi=4,qi=2))
plot (x,y, type="l", col="blue" ,main= "Criterio
      Nivel: F4 (con qi=2 y pi=4)")
```


```{r}
fpref.criterio_preflineal_indif_di = function(di,qi,pi) {
              #di = vaj-vah;
    if (di <= qi) {
      res= 0;
      } else if (di>pi) {
        res= 1;
      } else {
        res=(di-qi)/(pi-qi);
      }
       return(res) ;
  }
```





```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,function(xx) fpref.criterio_preflineal_indif_di(xx,pi=4,qi=2))
plot (x,y, type="l", col="blue" ,main= "Criterio Pref. Lineal Indiferencia: F5 (con qi=2 y pi=4)")
```


# Solución del problema 7 con Promethee

```{r}
sol7promethee2=multicriterio.metodo.promethee_ii(p7,
                                  pesos.criterios =
 c(0.25,0.25,0.2,0.2,0.2)/sum(c(0.25,0.25,0.2,0.2,0.2)), # para que sumen 1
                                  tab.fpref=matrix(c(1,0,0,0,
                                                   1,0,0,0,
                                                   1,0,0,0,
                                                   1,0,0,0,
                                                   1,0,0,0),ncol=4,byrow = TRUE )        )
sol7promethee2
```

```{r}
order(sol7promethee2$vflujos.netos,decreasing = T)
```

Por el método electre dijimos que la 4 era mejor que la 5 pero no conseguimos ordenar el resto. Este método si.


Método promethee:

- Matriz de valoraciones (si es minimizar cambio signo)
- Pesos, que deben sumar 1
- Funciones de pref de cada uno de los criterios, que espera que se lo pasemos como una matriz byrow=TRUE


# Problema 8 por método electre

Método electre:

- D
- Alpha
- Pesos de comparación, podríamos ponerlos todos infinitos




```{r}
sal8electre=multicriterio.metodoELECTRE_I(tabdec.X,
                                          pesos.criterios = rep(1/6,6),
                                   nivel.concordancia.minimo.alpha = 0.7,
                                   no.se.compensan = rep(Inf,6),
                                   que.alternativas = TRUE
                                   )
sal8electre$nucleo_aprox
```

Representación del grafo

```{r}
qgraph::qgraph(sal8electre$relacion.dominante)
```
En la siguiente iteración:

```{r}
sal8electrei2=multicriterio.metodoELECTRE_I(tabdec.X, pesos.criterios = rep(1/6,6),
                                   nivel.concordancia.minimo.alpha = 0.7,
                                   no.se.compensan = rep(Inf,6),
                                   que.alternativas = c(2,4,5))
                                   
sal8electrei2$nucleo_aprox
```


```{r}
qgraph::qgraph(sal8electrei2$relacion.dominante)
```

En la siguiente iteración:

```{r}
sal8electrei3=multicriterio.metodoELECTRE_I(tabdec.X, pesos.criterios = rep(1/6,6),
                                   nivel.concordancia.minimo.alpha = 0.55,
                                   no.se.compensan = rep(Inf,6),
                                   que.alternativas = c(2,4,5))
                                   
sal8electrei3$nucleo_aprox
```



```{r}
sal8electrei4=multicriterio.metodoELECTRE_I(tabdec.X, pesos.criterios = rep(1/6,6),
                                   nivel.concordancia.minimo.alpha = 0.505,
                                   no.se.compensan = rep(Inf,6),
                                   que.alternativas = c(4,5))
                                   
sal8electrei4$nucleo_aprox
```



Las dos mejores son la 4 y la 5, no consigo separar entre las dos