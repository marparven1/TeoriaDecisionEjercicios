---
title: "Teoría de la decisión"
subtitle: "Relación 2"
author: "Marta Venegas Pardo"
output: 
  prettydoc::html_pretty:
    theme: leonids
    highlight: github
    toc: true
    toc_depth: 4
    number_section: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

```{r  message=FALSE }
source("teoriadecision_funciones_multicriterio.R")
source("teoriadecision_funciones_multicriterio_diagram.R")
source("teoriadecision_funciones_multicriterio_utiles.R")
```

# Ejercicio 1 Construcción de funcion de valor o utilidad

Dadas las siguientes matrices correspondientes a la relación binaria no borrosa de preferencia-indiferencia:

Construya una función de valor o utilidad asociada a cada una de ellas.

Nota: A este ejercicio podemos resolverlo por el método borroso, pero el ejericio dos no podemos por el criterio maximal

## Apartado a)

### Método maximal

```{r}
m01A = multicriterio.crea.matrizvaloraciones(
  c(1,0,1,1,1,1,0,0,1), numalternativas = 3,
  v.nombres.alternativas = NULL
)
m01A
```

Método de construcción de la función de utilidad "Maximal".

```{r}
sol01A = multicriterio.constfuncutilidad.maximales(m01A)
sol01A
```

Ordenadas de mejor a peor:

```{r}
sort(sol01A,decreasing = TRUE)
```

### Método borroso

Método de construcción de la función de utilidad "Borroso"

```{r}
sol01A.bor = multicriterio.constfuncutilidad.estructuraborrosa(m01A)
sol01A.bor
```

Ordenadas de mejor a peor:

```{r}
sort(sol01A.bor,decreasing = TRUE)
```

Tambien dice que la menor es a2, luego a1 y la última a3.

## Apartado b)

```{r}
m01B = multicriterio.crea.matrizvaloraciones(
  c(1,0,1,1,1,1,1,0,1), numalternativas = 3,
  v.nombres.alternativas = NULL
)
m01B
```

```{r}
sol01B = multicriterio.constfuncutilidad.maximales(m01B)
sol01B
```

Ordenadas de mejor a peor:

```{r}
sort(sol01B,decreasing = TRUE)
```

## Apartado c) Falta MB

### Método maximal

```{r}
m01C = multicriterio.crea.matrizvaloraciones(
  c(1,1,1,1,1,1,1,1,1), numalternativas = 3,
  v.nombres.alternativas = NULL
)
m01C
```

```{r}
sol01C = multicriterio.constfuncutilidad.maximales(m01C)
sol01C
```

Ordenadas de mejor a peor:

```{r}
sort(sol01C,decreasing = TRUE)
```

### Método borroso

## Apartado d)

```{r}
m01D = multicriterio.crea.matrizvaloraciones(
  c(1,1,1,0,1,
    0,1,0,0,1,
    1,0,1,0,1,
    1,1,1,1,0,
    0,0,0,0,1), numalternativas = 5,
  v.nombres.alternativas = NULL
)
m01D
```

### Método maximal

Método de construcción de la función de utilidad "Maximal".

```{r}
sol01D = multicriterio.constfuncutilidad.maximales(m01D)
sol01D
```

Ordenadas de mejor a peor:

```{r}
sort(sol01D,decreasing = TRUE)
```

Las alternativas a1 y a3 son iguales, indiferentes.

$a_4 > a_1 = a_3 > a_2 > a_5$

### Método borroso

Método de construcción de la función de utilidad "Borroso"

```{r}
sol01D.bor = multicriterio.constfuncutilidad.estructuraborrosa(m01D)
sol01D.bor
```

Ordenadas de mejor a peor:

```{r}
sort(sol01D.bor,decreasing = TRUE)
```

En el método maximal había empate entre a1 y a3, sin embargo, este método coloca primero a a1.

$a_4 > a_1 > a_3 > a_2 > a_5$

# Ejercicio 2 Construcción de funcion de valor o utilidad

Dadas las siguientes matrices correspondientes a la relación binaria borrosa de preferencia:

Construya una función de valor o utilidad asociada a cada una de ellas.

## Apartado a)

```{r}
m02A = multicriterio.crea.matrizvaloraciones(
  c(0,0.4,0.7,
    0.2,0,0.5,
    0.3,0.6,0), 
  numalternativas = 3,
  v.nombres.alternativas = NULL
)
m02A
```

No se puede aplicar el método maximal

### Método borroso

Método de construcción de la función de utilidad "Borroso"

```{r}
sol02A.bor = multicriterio.constfuncutilidad.estructuraborrosa(m02A)
sol02A.bor
```

Ordenadas de mejor a peor:

```{r}
sort(sol02A.bor,decreasing = TRUE)
```

En este caso a1 sería la mejor, y existe un empate entre a2 y a3.

## Apartado B

```{r}
m02B = multicriterio.crea.matrizvaloraciones(
  c(0,0.2,0.4,
    0.9,0,0.8,
    0.1,0.3,0), 
  numalternativas = 3,
  v.nombres.alternativas = NULL
)
m02B
```

### Método borroso

Método de construcción de la función de utilidad "Borroso"

```{r}
sol02B.bor = multicriterio.constfuncutilidad.estructuraborrosa(m02B)
sol02B.bor
```

Ordenadas de mejor a peor:

```{r}
sort(sol02B.bor,decreasing = TRUE)
```


# Ejercicio 3

Dada una matriz de decisión

## Apartado a) Método Nadir

Homogenizar las columnas de la tabla por el método Método Nadir

```{r}
m03= multicriterio.crea.matrizdecision( 
  c(100,15,7,40,50,
    200,25,7,60,200,
    100,20,4,25,25,
    200,30,20,70,350,
    250,25,15,100,500), 
  numalternativas = 5,
  numcriterios = 5,
)
m03
```

### Con criterio maximinzar

Homogeneice las columnas de la tabla de decisión por el método Nadir

```{r}
sol03A=multicriterio.homogeneizacion.nadir(m03)
sol03A
```

-   Matriz en escala (0,1).

-   100 es el mínimo, por eso lleva valor 0 y 250 es el mayor, lleva un 1. Luego el resto es una regla de 3.

-   Así para cada criterio.

Nota: Si me dicen previamente que es minimizar, le cambio el signo a todo y me daría los 1 donde están los valores más pequeños:

### Apartado a con Criterio de minimizar

```{r}
m0302= multicriterio.crea.matrizdecision( 
  c(- 100,15,7,40,50,
    - 200,25,7,60,200,
    - 100,20,4,25,25,
    - 200,30,20,70,350,
    - 250,25,15,100,500), 
  numalternativas = 5,
  numcriterios = 5,
)
m0302
```

```{r}
sol03A02=multicriterio.homogeneizacion.nadir(m0302)
sol03A02
```

## Apartado b) Método Promethee

Homogenizar las columnas de la tabla por el método Promethee Considerando los siguientes valores $\underline\delta$ y $\overline\delta$ para cada uno de los criterios respectivamente:

-   C1 : (30, 120)
-   C2 : (3, 12)
-   C3 : (4, 10)
-   C4 : (20, 60)
-   C5 : (100, 400)

```{r}
sol03B =multicriterio.homogeneizacion.promethee(m03,
                                        v.delta.min = c(30,3,4,20,100),
                                        v.delta.max = c(120,12,10,60,400))
sol03B
```

# Ejercicio 4

Un inversor está considerando invertir en una opción entre dos alternativas posibles A y B. El criterio de mayor importancia relativa es el rendimiento de cada opción en Bolsa, y en menor medida el riesgo asociado con dicha inversión. Las matrices de comparación por pares de este problema han sido estimadas de la manera siguiente:

-   Matriz de criterios

|             | Rendimiento | Riesgo |
|-------------|-------------|--------|
| Rendimiento | 1           | 2      |
| Riesgo      | 1/2         | 1      |

-   Matriz de alternativas/criterios

| Rendimiento | Alternativa A | Alternativa B |
|-------------|---------------|---------------|
| Alt.A       | 1             | 3             |
| Alt.B       | 1/3           | 1             |

| Riesgo            | Alternativa A | Alternativa B |
|-------------------|---------------|---------------|
| Alt.A             | 1             | 2             |
| Alt.B             | 1/2           | 1             |

Se pide:

- Apartado a) Identificar el diagrama de jerarquías de este problema de decisión.

- Apartado b) Calcular las prioridades de cada matriz de comparaciones por pares.

- Apartado c) Determinar la prioridad global de cada una de las 2 inversiones.

Lo resuelvo siguiendo los pasos del fichero esquemaAHPcalculos

## Nuevo paquete

```{r}
#devtools::install_github("gluc/ahp", build_vignettes = TRUE)
```

```{r}
#vignette("car-example", package = "ahp")
#vignette("multiple-decisionmakers", package = "ahp")
#
## run analysis
#library(ahp)
#ahpFile <- system.file("extdata", "car.ahp", package="ahp")
#carAhp <- Load(ahpFile)
#Calculate(carAhp)
#Visualize(carAhp)
#Analyze(carAhp)
#AnalyzeTable(carAhp)
#
## looking at the vacation example, a multi-decision-maker model
#ahpFile <- system.file("extdata", "vacation.ahp", package="ahp")
#vacationAhp <- Load(ahpFile)
#Calculate(vacationAhp)
#Analyze(vacationAhp, decisionMaker = "Dad")
#AnalyzeTable(vacationAhp, decisionMaker = "Mom")
#AnalyzeTable(vacationAhp)
```

```{r}
#RunGUI()
```

## Solución con Funciones en script de R

### Paso 1: Introducir los datos



```{r}
# Matriz de Citerios
nb.criterios=c("Rendimiento","Riesgo")
tb0401 = multicriterio.crea.matrizvaloraciones_mej(c(2),
                                                  numalternativas = 2,
                                                  v.nombres.alternativas = nb.criterios) # la diagonal superior

tb0401
```

```{r}
# la del rendimiento
nb.alternativas=c("A","B")
tb0402a = multicriterio.crea.matrizvaloraciones_mej(c(3),
                                                  numalternativas = 2,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0402a
```

```{r}
# la del riesgo
nb.alternativas=c("A","B")
tb0402b = multicriterio.crea.matrizvaloraciones_mej(c(1/2),
                                                  numalternativas = 2,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0402b
```
### Paso 2: Obtenemos los pesos locales

Corresponden a $\$\text{valoraciones.AHP}$

```{r}
(pl0401 = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0401)) #pesoslocales0401
```

```{r}
(pl0402a = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0402a)) #pesoslocales0402a

```

```{r}
(pl0402b = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0402b)) #pesoslocales0402b
```



### Paso 3: Cálculo de pesos globales
Nos queda obtener finalmente los pesos globales:

```{r}
(sol04=multicriterio.metodoAHP.pesosglobales_entabla(pl0401$valoraciones.ahp,
                                              rbind(pl0402a$valoraciones.ahp,
                                                    pl0402b$valoraciones.ahp)))
```

Salida:

- Columna 1: Pesos locales del primer criterio (Rendimiento) para cada alternativa
- Columna 2: Pesos locales del segundo criterio (Riesgo) para cada alternativa
- Columna 3: Pesos globales 
- Columna 4: Pesos de cada criterio




Apartado b)

Prioridades de cada matriz de comparaciones por pares:

- En cuanto al rendimiento es 3 veces mejor la A que la B pero respecto al riesgo es mejor la B que la A. 

- El rendimiento tiene el doble de importancia que el riesgo, por eso gana la A, aunque hayamos obtenido que la alternativa B tiene el doble de peso en el criterio Riesgo.



apartado c)
Prioridad global:

- El 61% para la alternativa A y el 39% para la alternativa B. Esta claro que la alternativa elegida es la A, es casi el doble mejor.



### Paso 4: Diagrama de jerarquía

El diagrama con la estructura jerárquica:

```{r}
xmatn01=tb0401 # meto la tabla tb0401
xmatn02=array(NA,dim=c(2,2,2)) # 2 alternativas y dos criterios
xmatn02[,,1]=tb0402a
xmatn02[,,2]=tb0402b
dimnames(xmatn02)[[1]]=nb.alternativas
dimnames(xmatn02)[[2]]=nb.alternativas
dimnames(xmatn02)[[3]]=nb.criterios
multicriterio.metodoahp.diagrama(xmatn01,xmatn02) # matriz del nivel 1 y 2
```



## Solución Con paquete ahp

```{r}
#devtools::install_github("gluc/ahp", build_vignettes = TRUE)
# ahp::RunGUI()
# 
library(ahp)
dt04 = Load("ej04.ahp")
```

```{r message=FALSE}
#suppressPackageStartupMessages(Visualize(dt04))
#suppressMessages(Visualize(dt04))
Visualize(dt04)
```


### Pesos globales. Criterios/Subcriterios y Alternativas

```{r}
ahp::Calculate(dt04)
ahp::AnalyzeTable(dt04, sort="orig",variable="priority")
```
### Tabla para la interpretación
```{r}
ahp::AnalyzeTable(dt04, sort="orig")
```

- El rendimiento (33.33%) es casi el doble de importante que el riesgo (66.7%)

- El 66.7% de ese 33% es ese 22.2% de la alternativa B con respecto al riesgo.
- El 33% de ese 33%, que es el peso de la alternativa A con respecto al riesgo es ese (11%)

- El 16.7% ese sale del 25% del 66.7% del peso global del rendimiento.
- Por último, ese 50% se obtiene de que es el 75% del peso global del rendimiento (66.7%)






# Ejercicio 5

El vicepresidente ejecutivo de una empresa de distribución de bebidas necesita seleccionar un nuevo gerente de marketing.

Hay dos candidatos potenciales cuyas iniciales son A y B. Se han identificado las siguientes matrices de comparación por pares:

-   Matriz comparación entre Criterios

|             | Liderazgo | Habilidad Personal | Habilidad de Gestión |
|-------------|-----------|--------------------|----------------------|
| Liderazgo   |     1     |         1/3        |        1/4           |
| Habilidad Personal   |  3 |        1         |         2            |
| Habilidad de Gestión | 4 |        1/2        |         1            |



-   Matriz comparación entre Alternativas según Criterios

| Liderazgo | Alternativa A | Alternativa B   |
|-------------|---------------|---------------|
| Alt.A       | 1             |   4           |
| Alt.B       | 1/4           | 1             |

| Hab Personal | Alternativa A | Alternativa B |
|-------------------|---------------|---------------|
| Alt.A             | 1             | 3             |
| Alt.B             | 1/3           | 1             |

| Hab Gestión | Alternativa A | Alternativa B |
|-------------------|---------------|---------------|
| Alt.A             | 1             | 2             |
| Alt.B             | 1/2           | 1             |



Se pide:

- Apartado a) Identificar el diagrama de jerarquías de este problema de decisión
- Apartado b) Calcular las prioridades de cada matriz de comparaciones por pares
- Apartado c) Determinar la prioridad global de cada candidato.


## Solución con Funciones en script de R

### Paso 1: Introducir los datos


```{r}
# Matriz de Citerios
nb.criterios=c("Liderazgo", "Habilidad Personal",  "Habilidad de Gestión")
tb0501 = multicriterio.crea.matrizvaloraciones_mej(c(1/3,1/4,2),
                                                  numalternativas = 3,
                                                  v.nombres.alternativas = nb.criterios) # la diagonal superior

tb0501
```

```{r}
# la del liderazgo
nb.alternativas=c("A","B")
tb0502a = multicriterio.crea.matrizvaloraciones_mej(c(4),
                                                  numalternativas = 2,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0502a
```

```{r}
# la de habilidad personal
nb.alternativas=c("A","B")
tb0502b = multicriterio.crea.matrizvaloraciones_mej(c(3),
                                                  numalternativas = 2,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0502b
```

```{r}
# la del habilidad de gestión
nb.alternativas=c("A","B")
tb0502c = multicriterio.crea.matrizvaloraciones_mej(c(2),
                                                  numalternativas = 2,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0502c
```


### Paso 2: Obtenemos los pesos locales

```{r}
(pl0501 = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0501)) #pesoslocales0501
```

- El coeficiente de inconsistencia es 0.09297, se trata del valor frontera. Si está por debajo, las comparativas mantienen las reglas de las comparaciones y si por el contrario lo supera, debo revisar la matriz de comparaciones dos a dos, ya que tiene incongruencias.



```{r}
(pl0502a = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0502a)) #pesoslocales0402a

```

```{r}
(pl0502b = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0502b)) #pesoslocales0402b
```

```{r}
(pl0502c = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0502c)) #pesoslocales0402b
```



### Paso 3: Cálculo de pesos globales

Nos queda obtener finalmente los pesos globales:

```{r}
(sol05=multicriterio.metodoAHP.pesosglobales_entabla(pl0501$valoraciones.ahp, 
                                                     rbind(
                                                       pl0502a$valoraciones.ahp,         
                                                       pl0502b$valoraciones.ahp,  
                                                       pl0502c$valoraciones.ahp)))

```






Apartado b)
Prioridades de cada matriz de comparaciones por pares:

Vemos que en todos los criterios gana la alternativa A. El peso de la alternativa A es mejor que el de la B en todos los criterios.

Las prioridades de cada matriz de comparaciones por pares:

- En liderazgo el peso de la alternativa A cuadruplica al de la alternativa B, es decir, el liderazgo es 4 veces mejor en la alternativa A que en la B
- En habilidad personal, la alternativa A es tres veces mejor que la B
- En cuanto a habilidad de gestión, la primera alternativa es 2 veces mejor que la B




apartado c) Prioridad global:
- Solución: La alternativa elegida es la A
- El peso de la alternativa A es del 49.2% y de 17.8% para la alternativa B. Esta claro que la alternativa elegida es la A, la prioridad es más del doble. 
- El peso global del criterio HABILIDAD PERSONAL (51.71%) es bastante superior a los pesos del resto de criterios (12%) del criterio liderazgo y (35.8%) de habilidad de gestión. Por tanto, el criterio HABILIDAD PERSONAL será determinante de cara a tomar una decisión













### Paso 4: Diagrama de jerarquía

El diagrama con la estructura jerárquica:

```{r}
xmatn01=tb0501 # meto la tabla tb0501
xmatn02=array(NA,dim=c(2,2,3)) # dos alternativas y 3 criterios
xmatn02[,,1]=tb0502a
xmatn02[,,2]=tb0502b
xmatn02[,,3]=tb0502c

dimnames(xmatn02)[[1]]=nb.alternativas
dimnames(xmatn02)[[2]]=nb.alternativas
dimnames(xmatn02)[[3]]=nb.criterios
multicriterio.metodoahp.diagrama(xmatn01,xmatn02) # matriz del nivel 1 y 2
```






## Solución Con paquete ahp

```{r}
library(ahp)
dt05 = Load("ej05.ahp")
```

```{r message=FALSE}
Visualize(dt05)
```


### Pesos globales. Criterios/Subcriterios y Alternativas

```{r}
ahp::Calculate(dt05)
ahp::AnalyzeTable(dt05, sort="orig",variable="priority")
```
- Todas las inconsistencias se encuentran por debajo del 10%, que es el nivel de aceptación, por lo que está todo en orden.


### Tabla para la interpretación
```{r}
ahp::AnalyzeTable(dt05, sort="orig")
```

- Solución: La alternativa elegida es la A. Peso (49.2%)
- El peso global de la habilidad personal (34.7%) es bastante superior al resto de criterios, (19.8% habilidad de gestión y 12.5% el liderazgo)
- **Liderazgo**: De ese 12.5%, el peso de la Alternativa A era del 80%, por lo que obtenemos un peso del 10% total, mientras que para la alternativa B, el peso era de 20%, obteniendo únicamente un 2.5%
- **Habilidad personal**: De ese 34.7%, el peso de la Alternativa A era del 80%, por lo que obtenemos un peso del 10% total, mientras que para la alternativa B, el peso era de 20%, obteniendo únicamente un 6.6%
- **Habilidad de Gestión**: De ese 19.8%, el peso de la Alternativa A era del 66.7%, por lo que obtenemos un peso del 13.2% total, mientras que para la alternativa B, el peso era de 33.3%, obteniendo únicamente un 2.5%






# Ejercicio 6

Una empresa de diseño debe seleccionar la mejor oferta entre 3 alternativas de proveedores:

A, B y C.

La Gerencia de la empresa maneja tres criterios:
- (1) los costos
- (2) la confiabilidad de los productos
- (3) plazos de entrega

El centro decisor fue consultado sobre sus preferencias en relación con cada uno de los provee- dores. Se identificaron las siguientes matrices de comparación por parejas entre los proveedores según uno de los 3 criterios:


-   Matriz comparación entre Criterios

|             | Costo | Fiabilidad | Plazo Entrega |
|-------------|-----------|--------------------|----------------------|
| Costo   |     1     |         7        |        9          |
| Fiabilidad   |  1/7 |        1         |         3            |
| Plazo Entrega | 1/9 |        1/3        |         1            |





-   Matriz comparación entre Alternativas según Criterios

| Costo | Proveedor A | Proveedor B   | Proveedor C |
|-------------|---------------|---------------|-----|
| Proveedor A       | 1             |   1/3       |   6  |
| Proveedor B       | 3             | 1           |  8   |
| Proveedor C       | 1/6           | 1/8         |  1   |

| Confiabilidad | Proveedor A | Proveedor B | Proveedor C |
|-------------------|---------------|---------------|-----|
| Proveedor A       | 1             | 6       |  2   |
| Proveedor B       | 1/6           | 1       |  1/3   |
| Proveedor C       | 1/2           | 3             |   1  |

| Plazo Entrega | Proveedor A | Proveedor B | Proveedor C |
|-------------------|---------------|---------------|-----|
| Proveedor A             | 1             | 8       |   1  |
| Proveedor B             | 1/8           | 1       |  1/8   |
| Proveedor C       | 1           | 8             |  1   |


## Solución con Funciones en script de R

### Paso 1: Introducir los datos


```{r}
# Matriz de Citerios
nb.criterios=c("Costos", "Confiabilidad de productos",  "Plazos entrega")
tb0601 = multicriterio.crea.matrizvaloraciones_mej(c(7,9,3),
                                                  numalternativas = 3,
                                                  v.nombres.alternativas = nb.criterios) # la diagonal superior

tb0601
```


```{r}
# Costo
nb.alternativas=c("A","B","C")
tb0602a = multicriterio.crea.matrizvaloraciones_mej(c(1/3,6,8),
                                                  numalternativas = 3,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0602a
```



```{r}
# Confiabilidad
nb.alternativas=c("A","B","C")
tb0602b = multicriterio.crea.matrizvaloraciones_mej(c(6,2,1/3),
                                                  numalternativas = 3,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0602b
```

```{r}
# Plazo entrega
nb.alternativas=c("A","B","C")
tb0602c = multicriterio.crea.matrizvaloraciones_mej(c(8,1,1/8),
                                                  numalternativas = 3,
                                                  v.nombres.alternativas = nb.alternativas) # la diagonal superior

tb0602c
```




### Paso 2: Obtenemos los pesos locales

```{r}
(pl0601 = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0601)) #pesoslocales0601
```

- El coeficiente de inconsistencia es 0.069224, se trata del valor frontera. Si está por debajo, las comparativas mantienen las reglas de las comparaciones y si por el contrario lo supera, debo revisar la matriz de comparaciones dos a dos, ya que tiene incongruencias.



```{r}
(pl0602a = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0602a)) #pesoslocales0602a

```

```{r}
(pl0602b = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0602b)) #pesoslocales0602b
```

```{r}
(pl0602c = multicriterio.metodoAHP.variante1.autovectormayorautovalor(tb0602c)) #pesoslocales0602b
```



### Paso 3: Cálculo de pesos globales

Nos queda obtener finalmente los pesos globales:

```{r}
(sol05=multicriterio.metodoAHP.pesosglobales_entabla(pl0601$valoraciones.ahp, 
                                                     rbind(
                                                       pl0602a$valoraciones.ahp,         
                                                       pl0602b$valoraciones.ahp,  
                                                       pl0602c$valoraciones.ahp)))

```






Apartado b)
Prioridades de cada matriz de comparaciones por pares:


- Costos: De ese 78.5%, el peso del provedoor A era del 78.5%, por lo que obtenemos un peso del 22.4% total, mientras que para el proveedor B, el peso era de 28.5%, obteniendo únicamente un 22.4%. Por último, para el proveedor C, su peso global era del 65.3%, obteniendo así un peso del 51.3%

- Fiabilidad: De ese 14.9%, el peso del provedoor A era del 60%, por lo que obtenemos un peso del 8.9% total, mientras que para el proveedor B, el peso era de 10%, obteniendo únicamente un 2.5%. Por último, para el proveedor C, su peso global era del 30%, obteniendo así un peso del 4.5%

- Plazos de entrega: El peso de este criterio es el más bajo de todo. De ese 6.6%, el peso del provedoor A era del 45.7%, por lo que obtenemos un peso del 3.1% total, mientras que para el proveedor B, el peso era de 0.4%, obteniendo únicamente un 22.4%. Por último, para el proveedor C, su peso global era del 47.1%, obteniendo así un peso del 3.1%



apartado c) Prioridad global:

- Solución: La alternativa elegida es el proveedor B.
- El peso de esta alternativa B (53.13%) frente a un peso (34.41%) de la alternativa A  y (12.45%) de la alternativa C 
- El peso global del criterio COSTOS (78.53%) es bastante superior a los pesos del resto de criterios (14%) del criterio confiabilidad y (6%) de plazos de entrega. Por lo que este criterio será determinante de cara a tomar una decisión






### Paso 4: Diagrama de jerarquía

El diagrama con la estructura jerárquica:

```{r}
xmatn01=tb0601 # meto la tabla tb0501
xmatn02=array(NA,dim=c(3,3,3)) # dos alternativas y 3 criterios
xmatn02[,,1]=tb0602a
xmatn02[,,2]=tb0602b
xmatn02[,,3]=tb0602c

dimnames(xmatn02)[[1]]=nb.alternativas
dimnames(xmatn02)[[2]]=nb.alternativas
dimnames(xmatn02)[[3]]=nb.criterios
# library(diagram)
multicriterio.metodoahp.diagrama(xmatn01,xmatn02) # matriz del nivel 1 y 2
```






## Solución Con paquete ahp

```{r}
library(ahp)
dt06 = Load("ej06.ahp")
```

```{r message=FALSE}
Visualize(dt06)
```


### Pesos globales. Criterios/Subcriterios y Alternativas

```{r}
ahp::Calculate(dt06)
ahp::AnalyzeTable(dt06, sort="orig",variable="priority")
```
- Todas las inconsistencias se encuentran por debajo del 10%, que es el nivel de aceptación, por lo que está todo en orden.


### Tabla para la interpretación
```{r}
ahp::AnalyzeTable(dt06, sort="orig")
```

- Solución: La alternativa elegida es el proveedor B. Peso (53.1.2%) frente a un 12.5% del proveedor C y un 34.4% del proveedor A.

- El peso global del costo (78.5%) es bastante superior al resto de criterios, (14.9% de fiabilifaf y 6.6% para plazos de entrega) Por lo que el costo de los proveedores será determinante de cara a tomar la decisión.

- **Costos**: De ese 78.5%, el peso del provedoor A era del 78.5%, por lo que obtenemos un peso del 22.4% total, mientras que para el proveedor B, el peso era de 28.5%, obteniendo únicamente un 22.4%. Por último, para el proveedor C, su peso global era del 65.3%, obteniendo así un peso del 51.3%
- **Fiabilidad**: De ese 14.9%, el peso del provedoor A era del 60%, por lo que obtenemos un peso del 8.9% total, mientras que para el proveedor B, el peso era de 10%, obteniendo únicamente un 2.5%. Por último, para el proveedor C, su peso global era del 30%, obteniendo así un peso del 4.5%
- **Plazos de entrega**: El peso de este criterio es el más bajo de todo. De ese 6.6%, el peso del provedoor A era del 45.7%, por lo que obtenemos un peso del 3.1% total, mientras que para el proveedor B, el peso era de 0.4%, obteniendo únicamente un 22.4%. Por último, para el proveedor C, su peso global era del 47.1%, obteniendo así un peso del 3.1%








(b) Calcular las ponderaciones asociadas a cada criterio manejado.

- Criterio:COSTOS  78%
- Criterio Fiabilidad: 14.9%
- Criterio Plazos de entrega: 6.6%


(c) Calcular las ponderaciones de las 3 alternativas en función de cada criterio.

- Criterio:COSTOS Alt1 28.5%, Alt2 65.3%, Alt3 6.2%
- Criterio Fiabilidad:  Alt1 60.0%, Alt2 10.0%,Alt3 30.0%
- Criterio Plazos de entrega: Alt1 47.1%, Alt2 5.9%, Alt3 47.1%



(d) Verificar la consistencia de las preferencias del centro decisor.

- El coeficiente de inconsistencia es 0.069224, se trata del valor frontera. Si está por debajo, las comparativas mantienen las reglas de las comparaciones y si por el contrario lo supera, debo revisar la matriz de comparaciones dos a dos, ya que tiene incongruencias.


(e) Determinar la prioridad global de cada proveedor.

Proveedor A: 34.4%
Proveedor B: 53.1%
Proveedor C: 12.5%






# Ejercicio 7




## Iteración 1: Introduzco datos y resuelvo

```{r}
# EL ÚLTIMO CRITERIO ES DE MINIMIZAR
p7 = multicriterio.crea.matrizdecision(
  vector_matporfilas = c(
  100 ,15 ,7 ,40   ,-50,
  200 ,25 ,7 ,60   ,-200,
  100 ,20 ,4 ,25   ,-25,
  200 ,30 ,20, 70  ,-350,
  250 ,25 ,15, 100 ,-500),
  numalternativas = 5,
  numcriterios = 5
  
 
)
(w=c(0.25,0.25,0.2,0.2,0.2)) # PESOS (ponderación)
(vd = c(60,Inf,4,Inf,Inf)) #
```

Vemos que los criterios 1 y 2 tienen algo más de peso que el resto de criterios.



```{r}
sal7i1=multicriterio.metodoELECTRE_I(p7, # Matriz de decisión
                                     pesos.criterios = w, # Pesos de los criterios
                                   nivel.concordancia.minimo.alpha = 0.7, # Alfa mínimo
                                   no.se.compensan = vd, # Discordancia
                                   que.alternativas = TRUE # Considera TODAS
                                   )
#sal7i1
```

Representación del grafo

```{r}
qgraph::qgraph(sal7i1$relacion.dominante)
```

Conclusión:

- A3 no domina a nadie, no salen flechas
- A1 no domina a nadie
- A5 domina a A1, A2 y A3
- A4 somina a A1, A2 y A3
- A2 domina a A3 y A1

Tomamos como núcleo inicial:

```{r}
sal7i1$nucleo_aprox
```


## Iteración 2: Reduzco alternativas y/o alpha

En la siguiente iteración:




Método electre, pasos a seguir:

- Reducir el grafo a las alternativas en el núcleo. Si mi núcleo fuera de 3 en vez de dos, me quedo primero con 2 y luego aplico esto
- Reduzco $\alpha \in [0.5,1)$

```{r}
sal7i2=multicriterio.metodoELECTRE_I(p7,
                                     pesos.criterios = w,
                                     nivel.concordancia.minimo.alpha = 0.7,
                                     no.se.compensan = vd,
                                     que.alternativas = c(4,5) # El núcleo, vector con las alternativas que me quedan
                                   )
```




```{r}
sal7i2$nucleo_aprox
```

Pone 1 y 2 porque únicamente he dado dos alternativas.


```{r}
qgraph::qgraph(sal7i2$relacion.dominante)
```

## Tercera iteración: Reduzco alternativas y/0 alpha

Como no he obtenido relación de dominancia, reduzco el valor de alpha
En la siguiente iteración:

```{r}
sal7i3=multicriterio.metodoELECTRE_I(p7,pesos.criterios = w,
                                   nivel.concordancia.minimo.alpha = 0.55, #0.65, 0.6
                                    no.se.compensan = vd,
                                   que.alternativas = c(4,5)
                                   )
sal7i3$relacion.dominante
```

Tengo que A4 domina a A5


```{r}
sal7i3$nucleo_aprox # con 0.55 ya se queda solo a4
```



```{r}
qgraph::qgraph(sal7i3$relacion.dominante)
```

Si con 0.5 no somos capaces de establecer una superioridad, decimos que ambas son iguales y ninguna supera a la otra.

Conclusión, mejor alternativa: a4




## Promethee

```{r}
sol7promethee2=multicriterio.metodo.promethee_ii(p7,
                                  pesos.criterios =
 c(0.25,0.25,0.2,0.2,0.2)/sum(c(0.25,0.25,0.2,0.2,0.2)), # para que sumen 1
                                  tab.fpref=matrix(c(1,0,0,0,
                                                   1,0,0,0,
                                                   1,0,0,0,
                                                   1,0,0,0,
                                                   1,0,0,0),ncol=4,byrow = TRUE ))
sol7promethee2
```

```{r}
order(sol7promethee2$vflujos.netos,decreasing = T)
```

Por el método electre dijimos que la 4 era mejor que la 5 pero no conseguimos ordenar el resto. Este método si.

Método promethee:

-   Matriz de valoraciones (si es minimizar cambio signo)
-   Pesos, que deben sumar 1
-   Funciones de pref de cada uno de los criterios, que espera que se lo pasemos como una matriz byrow=TRUE








## Solución con método axiomático Arrow

```{r}
s7arrow=multicriterio.metodoaxiomatico.ArrowRaymond(p7)
```

```{r}
s7arrow$alternativasordenadas
```





## Solución con método axiomático de forma paramétrica

```{r}
p7
```

```{r}
intalfa=seq(1,0.5,by=-0.05)
intalfa # voy perdiento 5% cada vez
```

```{r}
sols= vector("list",length(intalfa))
for(i in 1:length(intalfa)){
  p7i = p7
  p7i[4,]=p7i[4,]*intalfa[i]
  sol= multicriterio.metodoaxiomatico.ArrowRaymond(p7i)
  sols[[i]]=sol$alternativasordenadas
}
  print(sols)
```
Para ver las posiciones de la alternativa "a4":

```{r}
posiciones_a4= rep(NA,length(intalfa))
for(i in 1:length(intalfa)){
  posiciones_a4[i]= which( sols[[i]]=="a4") # le digo que pos es
}
posiciones_a4
```

```{r}
plot(intalfa,posiciones_a4, type="o", main="Posiciones de la alternativa a4 \n Según alpha")
```
Empieza siendo la 1º, luego la 3º y luego la 4º finalmente.






# Ejercicio 8

## Promethee I

```{r}
tabdec.X = multicriterio.crea.matrizdecision(c(-80,90 , -6 , -5.4, -8,  5,
                                               -65,58 , -2  ,-9.7 , -1,   1,
                                               -83,60 , -4 , -7.2, -4,  7,
                                               -40,80 , -10, -7.5,  -7, 10,
                                               -52,72 , -6 , -2.0,  -3, 8,
                                              - 94,96 , -7  , -3.6 , -5,   6),
                                             numalternativas=6,
                                             numcriterios=6,
                                             v.nombresalt=c("A1","A2","A3","A4","A5","A6"),
                                             v.nombrescri = c("f1","f2","f3","f4","f5","f6")
                                                    
)
tabdec.X
```

```{r}
sal8= multicriterio.metodo.promethee_i(tabdec.X,
                                      pesos.criterios = rep(1/6,6), # porque son 6 criterios, 
                                      # la suma es 1 entre 6 criterios pues cada criterio 1/6
                                      # LOS PESOS DEBEN SUMAR 1
tab.fpref=matrix(c(2,10, 0, 0, # nro ,qi,pi,si
                   3,0,  30,0,
                   5,0.5,5, 0,
                   4,1,  6, 0,
                   1,0,  0, 0,
                   6,0,  0, 5),ncol=4,byrow=TRUE))
tab.fpref=matrix(c(2,10, 0, 0, # nro ,qi,pi,si
                   3,0,  30,0,
                   5,0.5,5, 0,
                   4,1,  6, 0,
                   1,0,  0, 0,
                   6,0,  0, 5),ncol=4,byrow=TRUE)
sal8
```




Representar en un grafo:

```{r}
qgraph::qgraph(sal8$tablarelacionsupera)
```

A5 domina a todos, esa es la mejor

### Medias

```{r}
Tab.Pthee.I_med_8= multicriterio.metodo.promethee_i_med(tabdecs.X = tabdec.X,
                                                        pesos.criterios = rep(1/6,6),
                                                        tab.fpref = tab.fpref)

Tab.Pthee.I_med_8
```


Representar en un grafo:

```{r}
qgraph::qgraph(Tab.Pthee.I_med_8$tablarelacionsupera)
```


## Promethee II

```{r}
sal8b= multicriterio.metodo.promethee_ii(tabdec.X,
                                      pesos.criterios = rep(1/6,6),
                 tab.fpref=matrix(c(2,10,0,0, # nro ,qi,pi,si
                                    3,0,30,0,
                                    5,0.5,5,0,
                                    4,1,6,0,
                                    1,0,0,0,
                                    6,0,0,5),ncol=4,byrow=TRUE))
tab.fpref=matrix(c(2,10,0,0, # nro ,qi,pi,si
                                    3,0,30,0,
                                    5,0.5,5,0,
                                    4,1,6,0,
                                    1,0,0,0,
                                    6,0,0,5),ncol=4,byrow=TRUE)
sal8b
```

Representar en un grafo:

```{r}
qgraph::qgraph(sal8b$tablarelacionsupera)
```

La 5 domina a todos y nadie le domina.

```{r}
order(sal8b$vflujos.netos,decreasing = T)
```

Me dice que la 5 es la mejor seguida de la 2, la 4 la 6 la 3 y la 1.

```{r}
pesos.criterios = c(1/6,1/6,1/6,1/6,1/6.1/6) ;
#                   num. función, qi, pi, si
tab.fpref = matrix(c (2,10,1,0,
                      3,0,30,0,
                      5,0.5,5,0, 
                      4,1,6,0,
                      1,0,1,0,
                      6,0,1,5) ,ncol=4, byrow=T);
# tab.fpref
```






### Medias

```{r}
Tab.Pthee.II_med_8= multicriterio.metodo.promethee_ii_med( tabdecs.X = tabdec.X,
                                                           pesos.criterios = rep(1/6,6),
                                                          tab.fpref   =  tab.fpref)
Tab.Pthee.II_med_8
```




Representar en un grafo:

```{r}
qgraph::qgraph(Tab.Pthee.II_med_8$tablarelacionsupera)
```



Ordenación final con promethee II medias 

```{r}
order(Tab.Pthee.II_med_8$vflujos.netos,decreasing = T)
```

### Comparativas con y sin medias

```{r}
order(sal8b$vflujos.netos,decreasing = T)
```



```{r}
order(Tab.Pthee.II_med_8$vflujos.netos,decreasing = T)
```

La ordenación es la misma.

## Representación gráfica de las funciones de preferencia


```{r}
fpref.criterio_usual_di = function(di) {
              #di = vaj-vah;
    if (di <= 0) {
      res= 0;
      } else {
        res= 1;
      }
       return(res) ;
  }
```

Representación Gráfica de las funciones de preferencias

```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,fpref.criterio_usual_di)
plot (x,y, type="l", col="blue" ,main= "Criterio Usua: F1 ")
```

```{r}
fpref.cuasi_criterio_di = function(di,qi) {
              #di = vaj-vah;
    if (di <= qi) {
      res= 0;
      } else {
        res= 1;
      }
       return(res) ;
  }
```

```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,function(xx) fpref.cuasi_criterio_di(xx,qi=2))
plot (x,y, type="l", col="blue" ,main= "Cuasi Criterio. Lineal: F2 (con qi=2)")
```

```{r}
fpref.criterio_preflineal_di = function(di,pi) {
              #di = vaj-vah;
    if (di <= 0) {
      res= 0;
      } else if (di>pi) {
        res= 1;
      } else {
        res=di/pi;
      }
       return(res) ;
  }
```

```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,function(xx) fpref.criterio_preflineal_di(xx,pi=2))
plot (x,y, type="l", col="blue" ,main= "Criterio
      Pref. Lineal: F3 (con pi=2)")
```

```{r}
fpref.criterio_nivel_di = function(di,qi,pi) {
              #di = vaj-vah;
    if (di <= qi) {
      res= 0;
      } else if (di>pi) {
        res= 1;
      } else {
        res=0.5;
      }
       return(res) ;
  }
```

```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,function(xx) fpref.criterio_nivel_di(xx,pi=4,qi=2))
plot (x,y, type="l", col="blue" ,main= "Criterio
      Nivel: F4 (con qi=2 y pi=4)")
```

```{r}
fpref.criterio_preflineal_indif_di = function(di,qi,pi) {
              #di = vaj-vah;
    if (di <= qi) {
      res= 0;
      } else if (di>pi) {
        res= 1;
      } else {
        res=(di-qi)/(pi-qi);
      }
       return(res) ;
  }
```

```{r}
x= seq(-10,10 ,length.out=100)
y= sapply (x,function(xx) fpref.criterio_preflineal_indif_di(xx,pi=4,qi=2))
plot (x,y, type="l", col="blue" ,main= "Criterio Pref. Lineal Indiferencia: F5 (con qi=2 y pi=4)")
```

## Método electre

Método electre:

-   D
-   Alpha
-   Pesos de comparación, podríamos ponerlos todos infinitos

### Primera iteración


```{r}
sal8electre=multicriterio.metodoELECTRE_I(tabdec.X,
                                          pesos.criterios = rep(1/6,6),
                                          nivel.concordancia.minimo.alpha = 0.7,
                                          no.se.compensan = rep(Inf,6),
                                          que.alternativas = TRUE
                                   )
sal8electre$nucleo_aprox
```

Representación del grafo

```{r}
qgraph::qgraph(sal8electre$relacion.dominante)
```

### Segunda iteración

En la siguiente iteración:

```{r}
sal8electrei2=multicriterio.metodoELECTRE_I(tabdec.X, pesos.criterios = rep(1/6,6),
                                            nivel.concordancia.minimo.alpha = 0.7,
                                            no.se.compensan = rep(Inf,6),
                                            que.alternativas = c(2,4,5))
                                   
sal8electrei2$nucleo_aprox
```
El núcleo es el mismo que antes. Tengo que bajar alpha



```{r}
qgraph::qgraph(sal8electrei2$relacion.dominante)
```

### Tercera iteracción

En la siguiente iteración:

```{r}
sal8electrei3=multicriterio.metodoELECTRE_I(tabdec.X, pesos.criterios = rep(1/6,6),
                                   nivel.concordancia.minimo.alpha = 0.55,
                                   no.se.compensan = rep(Inf,6),
                                   que.alternativas = c(2,4,5))
                                   
sal8electrei3$nucleo_aprox
```


Ahora el núcleo son las alternativas 4 y 5.

### Cuarta iteración

```{r}
sal8electrei4=multicriterio.metodoELECTRE_I(tabdec.X, pesos.criterios = rep(1/6,6),
                                   nivel.concordancia.minimo.alpha = 0.505,
                                   no.se.compensan = rep(Inf,6),
                                   que.alternativas = c(4,5))
                                   
sal8electrei4$nucleo_aprox
```
Las dos mejores son la 4 y la 5, no consigo separar entre las dos.


### Cálculos en el método electre I La representación de las tables de test con KableExtra

```{r}
library(dplyr)
library(kableExtra)
library(stringr)
sal8ke = func_ELECTRE_Completo(sal8electre)
```

```{r}
sal8ke$MIndices
```



Con respecto a A1

- En el criterio 2 A1sA5
- En el criterio 3 y 4 A1sA4


- A1 no supera a A2 en los criterios 1, 3 y 5
- En los criterios 1,3,5 a1 peor a2






```{r}
sal8ke$TConcordancia
```



Notación:

- F= NO PASA EL TEST DE CONCORDANCIA
- RESULTADO AZUL: PAREJAS QUE PASAN EL TEST DE CONCORDANCIA

Sólo pasan el test de corcondancia:

- A5SA1
- A5SA3
- A5SA6


```{r}
sal8ke$TDiscordancia
```

Notación:

- F= NO PASA EL TEST DE DISCORDANCIA
- RESULTADO AZUL: PAREJAS QUE PASAN EL TEST DE DISCORDANCIA
- LA DIAGONAL SE SUPERA ENTERA PERO NO VA A INFLUIR

Las alternativas que pasaban el test de concordancia también pasan el de discordancia.
- A5SA1
- A5SA3
- A5SA6



```{r}
sal8ke$TSuperacion$KE
```

CONCLUSIÓN:

- A5SA1
- A5SA3
- A5SA6

```{r}
sal8ke$Grafo
```



```{r}
qgraph::qgraph(sal8ke$Grafo)
```

El núcleo

```{r}
sal8ke$Nucleo
```












